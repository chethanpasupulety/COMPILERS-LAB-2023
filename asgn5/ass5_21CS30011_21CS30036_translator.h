#ifndef __TRANSLATOR_H
#define __TRANSLATOR_H

#include <iostream>
#include <vector>
#include <list>
using namespace std;

#define __VOID_SIZE 0
#define __FUNCTION_SIZE 0
#define __CHARACTER_SIZE 1
#define __INTEGER_SIZE 4
#define __POINTER_SIZE 4
#define __FLOAT_SIZE 8

class symbol;
class symbolType;   // symbolType - Represents the type of an element in the symbol table
class symbolTable;  // symbolTable - Represents the symbol table data structure itself

class quad;         // Denotes a quad in the Three Address Code translation
class quadArray;    // Denotes the entire list of quads


//Global variables used:

extern symbol* currSymb;            // Pointer to the current symbol
extern symbolTable* currSymTab;     // Pointer to the currently active symbol table
extern symbolTable* globalSymTab;   // Pointer to the global symbol table
extern quadArray quadList;          // The list of quads
extern int SymTabCount;             // A count variable used for naming nested symbol tables
extern string blockName;            // A variable used for naming nested blocks in symbol tables


// External variables and methods generated by bison
extern char* yytext;
extern int yyparse();


class symbolType {
public:
    string type;   
    int width;              //In case of arrays, it represents the size, for basic types it is 1
    symbolType* arrType;    //For arrays, it points to the type of the elements in the array

    symbolType(string type_, symbolType* arrType_ = NULL, int width_ = 1);  //Constructor
};


class symbol {
public:
    string name;    
    symbolType* type;   
    string value;               //Initial value of the symbol, if any
    int size;                   //Size of the symbol(element)
    int offset;                 //Offset of the symbol in the symbol table
    symbolTable* nestedTable;   //Pointer to a nested symbol table, if any (useful for functions and blocks)

    symbol(string name_, string t = "int", symbolType* arrType = NULL, int width = 0);  //Constructor
    symbol* update(symbolType* t);  //Update the contents of an existing symbol
};



class symbolTable {
public:
    string name;    
    int tempCount;          //Count of temporary variables generated for the symbol table
    list<symbol> table;     //List of all symbols present in the symbol table
    symbolTable* parent;    //Pointer to the parent of the symbol table, NULL for the global symbol table

    symbolTable(string name_ = "NULL"); //Constructor

    symbol* lookup(string name);    //A method to lookup an id (given its name or lexeme) in the symbol table. If the id exists, the entry is returned, otherwise a new entry is created.
    static symbol* gentemp(symbolType* t, string initValue = "");   //A static method to generate a new temporary, insert it to the symbol table, and return a pointer to the entry

    void print();   //Prints the symbol table in a suitable fashion
    void update();  //Updates different fields of an existing entry
};


class quad {
public:
    string op;      //Operator in the three address code
    string arg1;    //First argument in the three address code
    string arg2;    //Second argument in the three address code
    string result;  //Result of the three address code

    //Constructors
    quad(string res, string arg1_, string operation = "=", string arg2_ = "");
    quad(string res, int arg1_, string operation = "=", string arg2_ = "");
    quad(string res, float arg1_, string operation = "=", string arg2_ = "");

    void print();   //Prints the quad in a suitable fashion
    void quadprint();
};




class quadArray {
public:
    vector<quad> quads; //A vector of all the quads generated

    void print();   //Prints the entire list of quads
};



class Array {
public:
    string atype;       //Type of the array, either "arr" or "ptr"
    symbol* loc;        //Location to compute address of the array
    symbol* Array;      //Symbol table entry for the array
    symbolType* type;   //Type of the array generated, used for multidimensional arrays
};



class statement {
public:
    list<int> nextlist; //Nextlist for the statement
};



class expression {
public:
    string type;    
    symbol* loc;            //Pointer to the symbol table entry 
    list<int> truelist;     //Truelist for boolean expressions
    list<int> falselist;    //Falselist for boolean expressions
    list<int> nextlist;     // Nextlist for statement expressions
};


void emit(string op, string result, string arg1 = "", string arg2 = "");
void emit(string op, string result, int arg1, string arg2 = "");
void emit(string op, string result, float arg1, string arg2 = "");


list<int> makelist(int i);

list<int> merge(list<int> &list1, list<int> &list2);

void backpatch(list<int> l, int address);

// Checks compatibility of the types of the symbols s1 and s2 Overloaded for symbol types also
bool typecheck(symbol* &s1, symbol* &s2);
bool typecheck(symbolType* t1, symbolType* t2);

// Converts a symbol of one type to another and returns a pointer to the converted symbol

symbol* convertType(symbol* s, string t);

expression* convertIntToBool(expression* expr);

expression* convertBoolToInt(expression* expr);

void switchTable(symbolTable* newTable);

int nextInstr();

int typeSz(symbolType* t);

string checkType(symbolType* t);

#endif